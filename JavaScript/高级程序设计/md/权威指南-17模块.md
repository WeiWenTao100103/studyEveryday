
## 模块

### 理解模块模式

模块的思想：把逻辑分块，各自封装，相互独立，每个块决定对外暴露什么内容，同时自行决定引入执行那些外部代码

在浏览器中，加载模块的步骤：

1. 加载模块涉及执行其中的代码，但必须是所有依赖都加载并执行之后
2. 如果浏览器没有收到依赖模块的代码，则必须发送请求并等待网络返回
3. 收到模块代码之后，浏览器必须确定刚收到的模块是否也有依赖
4. 递归地评估并加载所有依赖，直到所有依赖模块都加载完成
5. 当所有依赖图都加载完成，才可以执行入口模块

### CommonJS

CommonJS规范概述了同步声明依赖的模块定义。这个规范主要用于在服务器端实现模块化代码组织，但也可用于定义浏览器中使用的模块依赖。CommonJS模块语法不能在浏览器中直接运行。

**⚠️Node.js使用的是轻微修改的CommonJS，因为Node.js主要在服务器环境中使用，所以不需要考虑网络延迟**

```js
module.exports = {
    id : "modelA"
}

const modelA =  require("./modela.js")
console.log(modelA) //{ id: 'modelA' }
```

require()意味着模块会原封不动的加载进来

无论一个模块在require中被引用多少次，模块永远是单列

模块第一次被加载后会被缓存



### ES6模块

ES6最大的一个改进就是引入了人模块规范。简化了之前出现的模块加载器。原生浏览器的支持意味着加载器和其他预处理器都不在必要

#### 模块标签及定义

ES6模块是做为一整块JavaScript代码存在的。带有type="model"属性的\<script\>标签会告诉浏览器相关代码应该作为模块执行，而不是作为传统的脚本执行。

与传统的脚本不同，所有模块都会像\<script defer \>加载的脚本一样按顺序执行。**解析到\<script type="module" \>标签后会立即下载模块文件，但会在文档解析完成后按顺序执行**

也可以给模块标签添加async属性。这样会让模块在下载完就执行

#### 模块加载

ES6模块的独特在于，既可以通过浏览器原生加载，也可以与第三方加载器和构建工具一起加载。

**支持ES6模块的浏览器可以从顶级模块加载整个依赖图，且是异步完成的。浏览器会解析入口模块，确定依赖，并发送对依赖模块的请求。这些文件通过网络返回后，浏览器就会解析他们的内容，确认它们的依赖，如果二级依赖还没有加载，则会发送更多请求。这个异步递归加载过程会持续到整个应用程序的依赖图都解析完成。应用程序就会开始正式加载模块。**

⚠️

- import语句会被提升到模块顶部
- 如果浏览器通过标识符原生加载模块，则文件必须带有.js扩展名，不然可能无法解析

#### 模块行为

ES6模块借用了CommonJS和AMD的很多特性

- 模块代码只在加载后执行
- 模块只能加载一次
- 模块是单列
- 模块可以定义公共接口，其他模块可以基于这个公共接口观察和交互
- 模块可以请求加载其他模块
- 支持循环依赖

ES6模块系统也增加了一些新行为

- ES6模块默认在严格模式下执行
- ES6模块不共享全局命名空间
- 模块顶级this的值是undefined（常规脚本是window）
- 模块中的var声明不会添加到window对象
- ES6模块是异步加载执行的

与\<script type="module" \>关联或者通过import语句加载的JavaScript文件会被认定为模块

