

# 面试题

## 输出以下代码运行结果，为什么？如果希望每隔 1s 输出一个结果，应该如何改造？注意不可改动 square 方法

```javascript
const list = [1, 2, 3]
const square = num => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve(num * num)
    }, 1000)
  })
}

function test() {
  list.forEach(async x=> {
    const res = await square(x)
    console.log(res)
  })
}
test()
```

[^注意]: forEach遍历传进square的num会被 Promise保存



```js
输出结果为：
--1
--4
--9
```

```js
改造
因为forEach是数组的一个方法，接受的是一个回调函数(forEach() 方法对数组的每个元素执行一次给定的函数。)
function test() {
    list.forEach(async x=> {
        const res = await square(x)
        console.log(res)
    })

    //forEach循环等于三个匿名函数;
    (async (x) => {
        const res = await square(x)
        console.log(res)
    })(1);
    (async (x) => {
        const res = await square(x)
        console.log(res)
    })(2);
    (async (x) => {
        const res = await square(x)
        console.log(res)
    })(3);

    // 上面的任务是同时进行
}
//改造后
 async function test() {
    for (let x of list) {
      const res = await square(x)
      console.log(res)
    }
  }
  //等价于

  async function test() {
      const res = await square(1)
      console.log(res)
      const res2 = await square(2)
      console.log(res)
      const res3 = await square(3)
      console.log(res)
  }
```

## ['1', '2', '3'].map(parseInt) what & why ?

这里主要用到了两个api Array.map & parseInt

###### Array.map

map() 方法创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值。生成新数组元素的函数。可使用三个参数currentValue(callback 数组中正在处理的当前元素。),index(callback 数组中正在处理的当前元素的索引。),array(map 方法调用的数组。)

通常情况下，map 方法中的 callback 函数只需要接受一个参数，就是正在被遍历的数组元素本身。但这并不意味着 map 只给 callback 传了一个参数。**这个思维惯性可能会让我们犯一个很容易犯的错误**。接下来我们先看看默认接收到的参数

```js
function log(...arg){console.log(arg)}
['1', '2', '3'].map(log)

//打印如下，由此可知默认接受三个参数currentValue，index，array
["1", 0, Array(3)]
["2", 1, Array(3)]
["3", 2, Array(3)]
```

###### parseInt

parseInt(**string, radix**)   将一个字符串 string 转换为 radix 进制的整数， radix 为介于2-36之间的数。

**string:**要被解析的值。如果参数不是一个字符串，则将其转换为字符串(使用  ToString 抽象操作)。字符串开头的空白符将会被忽略。
**radix:** 可选  从 2 到 36，代表该进位系统的数字。例如说指定 10 就等于指定十进位。请注意，通常预设值不是 10 进位！

```js
parseInt('123', 5)
//将'123'看作5进制数，返回十进制数38 => 1*5^2 + 2*5^1 + 3*5^0 = 38
```

如果 radix 是 undefined、0或未指定的，JavaScript会假定以下情况：

1. 如果输入的 string以 "0x"或 "0x"（一个0，后面是小写或大写的X）开头，那么radix被假定为16，字符串的其余部分被解析为十六进制数。

2. 如果输入的 string以 "0"（0）开头， radix被假定为8（八进制）或10（十进制）。具体选择哪一个radix取决于实现。ECMAScript 5 澄清了应该使用 10 (十进制)，但不是所有的浏览器都支持。因此，在使用 parseInt 时，一定要指定一个 radix。

3. 如果输入的 string 以任何其他值开头， radix 是 10 (十进制)。

   ***<u>(我们一般遇到的大多是10进制)</u>***

接下来我们再看这道题目

```js
['1', '2', '3'].map(parseInt) 
//以上分析后得出迭代步骤为
parseInt("1", 0,['1', '2', '3'])
parseInt("2", 1,['1', '2', '3'])
parseInt("3", 2,['1', '2', '3'])
//所有其实真正执行的代码是
parseInt("1", 0) //1
parseInt("2", 1) //NaN
parseInt("3", 2) //NaN
```

## 计算页面中出现次数最多的三个标签

```js
//获取到所有的标签
const tags = document.getElementsByTagName('*') 
const getMaxs={}
//循环计算每个标签出现的次数，键值对保存
for (var i = 0; i < tags.length; i++) {
    var item = tags[i].tagName;
    if (getMaxs[item]) {
        getMaxs[item]++;
    } else {
        getMaxs[item] = 1;
    }
}
//排序
Object.keys(getMaxs).sort((a,b)=>{return getMaxs[b]-getMaxs[a]})
```

## 代码的打印结果

```js
function Foo() {
    Foo.a = function() {
        console.log(1)
    }
    this.a = function() {
        console.log(2)
    }
}
Foo.prototype.a = function() {
    console.log(3)
}
Foo.a = function() {
    console.log(4)
}
Foo.a();   //4 在没有被new操作之前内部赋值不会被执行，prototype也不会生效
let obj = new Foo();
obj.a();  //2 this的关系，this指向了obj，而 Foo.a 赋值不会指向obj
Foo.a();  //1 new操作在后，所以内部的Foo.a赋值会覆盖到最后
```

```js
function changeObjProperty(o) {
  o.siteUrl = "http://www.baidu.com"
  o = new Object()
  o.siteUrl = "http://www.google.com"
} 
let webSite = new Object();
changeObjProperty(webSite);
console.log(webSite.siteUrl); //"http://www.baidu.com"
//1.定义一个空对象webSite
//2.将空对象传入changeObjProperty时 o和webSite指针指向同一个空对象
//3.第一次赋值o.siteUrl时，赋值到了第一个空对象内
//4.o = new Object()这时改变了内部o的指针，指向了一个新的空对象
//5.这时再次赋值o.siteUrl时， o和webSite的指针已经不指向同一个地址，所以此时的赋值不会对webSite指向的内容产生影响
```

