## 缓存

**获取数据的速度： 内存获取 < 硬盘获取 < 网络获取**

Web缓存是可以自动保存常见文档副本的HTTP设备。当Web请求抵达缓存时，如果本地有“已缓存的”副本，就可以从本地存储设备而不是原始服务器中提取这个文档。

使用缓存的优点

- 缓存减少了冗余的数据传输，节省了网络费用
- 缓存缓解了网络瓶颈的问题，不需要更多的带宽就能更快的加载页面
- 缓存降低了对原始服务器的要求，服务器可以更快的响应，避免过载的出现
- 缓存降低了距离延时，因为从较远的地方加载页面会更慢一些

使用缓存的缺点

​	在开发中经常会由于浏览器缓存而展示了【错误】的东西

### 客户端缓存

#### memory cache（浏览器内存缓存）

当当前页面被关闭的时候会被清除

#### disk cache（磁盘高速缓存）

一般不清除，只能手动清除或者过期了再去服务端请求



当一个请求第一次被返回的时候浏览器根据response头信息的**Cache-Control**和**Expires**来判断是否缓存资源副本

#### Cache-Control

- private 只能客户端缓存，不允许代理服务器进行缓存
- public 都可以进行，客户端以及代理服务器，如cdn
- no-Store 禁止缓存对响应进行复制
- no-Cache 可以存储在本地缓存区。对资源再验证后客户端才会接受已缓存的资源
- max-age 表示从服务端将文档传来时起，此文档处于新鲜度的秒数（几秒后缓存过期）
- s-maxage 与max-age类似
- must-revalidate 在没有验证原始数据的情况下，不能提供旧的副本
- max-stale 缓存可以随意提供过期的文件。如果制定了max-stale = <s>文档就不能过期
- min-fresh=<s> 至少在未来s秒内文档要保持新鲜
- only-if-cached 只有当缓存中有副本时，客户端才会获取一份副本

```js
ctx.response.set(
  "Cache-Control",'max-age=5;public'
  //设置缓存5秒后过期
);
```

#### Expires

指定一个绝对过期日期，如果日期已经过了，说明文档不再新鲜

```js
ctx.response.set(
  "Expires",new Date(new Date().getTime()+5000)
);
```



**ETag**（实体标识）优先验证**ETag**标识

**Last-Modified**（最后修改时间）只能精确到秒级



### CDN缓存

CDN（Content Delivery Network）内容分发网络。

客户端直接从源站点获取数据，当服务器访问量大时会影响访问速度，进而印象用户体验，且无法保证客户端与源站点间的距离足够短，适合传输数据。CDN解决的正是如何将数据快速可靠的从源站点传递到客户端，通过CDN对数据的分发，用户可以从一个距离较近的服务器获取数据，而不是源站点，从而达到快速访问。







### 冗余的数据传输

当很多客户端访问一个原始服务器页面时，服务器会多次传输同一份文档给不同的客户端。一些相同的字节会在网络中一遍遍的传输，这些冗余的数据传输会耗费昂贵的网络带宽，降低传输速度，加重Web服务器的负载。有了缓存，就可以保留第一条服务器响应的副本，后续请求就可以由缓存的副本来应对了。

### 瞬间拥堵（Web服务器过载）

缓存在破坏瞬间拥堵时显得非常重要。突发事件（爆炸新闻、批量E-mail、名人事件）时很多人几乎同时去访问一个网站，就出现瞬间拥堵。由此造成的过多流量峰值可能会使网络和Web服务器产生灾难性的奔溃（微博热搜）

### 距离时延

即使带宽不是问题，距离也可能成为问题。每台网络路由器都会增加因特网流量的时延。即使客户端和服务器之间没有太多的路由器，光速自身也会造成显著的时延。（在实际应用中，信号的传输速度会比光速低一些）

将缓存存放在附近的机房里可以将文件的传输距离降低

### 命中和未命中的

虽然缓存很有帮助，但是缓存无法保存所有的每份文档的副本（而且原始的文档中的内容也有可能会变化）。当已有的副本为某些到达缓存的请求提供服务，这被称为**缓存命中**。其他的一些到达缓存的请求，可能没有副本可用，而被转发到原始服务器，这些被称为**缓存未命中**

#### 再验证

原始服务器的内容可能会发生变化，缓存要不时对其进行检测，看看他们保存的副本是否仍是服务器最新的副本，这就是HTTP再验证（revalidation）。为了有效的进行验证，HTTP定义了一些特殊的请求，不用从服务器上获取整个对象，就可以检测出内容是否时最新的。

缓存对缓存的副本进行验证时，会向原始服务器发送一个小的再验证请求。如果内容没有变化，服务器会以一个小的 **304 Not Modified**进行响应。只要缓存知道副本仍然有效，就会再次将副本标示为暂时新鲜的，并将副本提供给客户端（这被称为**再验证命中**或**缓存命中**）

HTTP为我们提供了几个用来对缓存对象再验证的工具，但最常用的事If-Modified-Since首部。将这个首部添加到GET请求中去，就可以告诉服务器，只有在缓存了对象的副本之后，又对其进行了修改的情况下，才发送此对象。

服务器收到 GET If-Modified-Since请求时会发生的情况

- 再验证命中 HTTP 304 Not Modified
- 再验证未命中 HTTP 200 OK
- 对象被删除 HTTP 404 Not Found

#### 文档命中率

由缓存提供服务的请求所占比例叫做**缓存命中率**，0%表示从未命中，100%表示每次请求都命中了

对现代中等规模的Web缓存来说，40%的命中率是很合理的

#### 字节命中率

由于文档并不是同一尺寸的，所以文档命中率并不能说明一切，有些大文件对象被访问的次数较少，但是由于尺寸的原因，对整个数据流量的贡献却很大

#### 区分命中和未命中的情况

不幸的是，HTTP没有为用户提供一种手段来区分响应时缓存命中的，还是访问原始服务器得到的。这两种情况下，响应码都是 200 OK ，说明响应有主体部分。有些商业代理缓存会在via首部附加一些额外信息，以描述缓存发生的情况。

客户端有一种方法可以判断响应是否来自缓存，就是Date首部，将响应中Date首部的值与当前时间进行比较，如果响应中的日期值比较早，通常认为这是一条缓存的响应。客户端也可以通过Age首部来检测缓存的响应

#### 文档过期





