<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <canvas id="canvas"></canvas>
</body>
<script type="module">
    import {initShaders} from "./utils/utils.js"
    import { Matrix4, Vector2, Vector3, Quaternion, Object3D, OrthographicCamera, Spherical } from 'https://unpkg.com/three/build/three.module.js';
    import Poly from "./utils/Poly.js"
    const VSHADER_SOURCE = `
        attribute vec4 a_Position;
        uniform mat4 pvMatrix;
        uniform mat4 u_ModelMatrix;
        void main() {
            gl_Position = pvMatrix * u_ModelMatrix * a_Position; // 设置坐标位置
            gl_PointSize = 10.0; // 设置尺寸
        }
    `
    const FSHADER_SOURCE = `
        precision mediump float;
        uniform vec4 u_Color;
        void main(){
            gl_FragColor = u_Color; // 设置颜色
        }
    `
    canvas.width= window.innerWidth;
    canvas.height= window.innerHeight;
    // 获取WebGL绘图上下文
    const gl = canvas.getContext('webgl');
    initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)
    // 指定清空canvas的颜色
    gl.clearColor(0, 0, 0, 1);

    const halfH = 2
    const ratio = canvas.width/canvas.height
    const halfW = halfH*ratio
    const [left,rignt,top,bottom,near,far] = [
        -halfW, halfW, halfH, -halfH, 1, 8
    ]
    const eye = new Vector3( 1, 1, 2)
    const target = new Vector3(0, 0, -3)
    const up = new Vector3(0, 1, 0)
    const zoomScale = 0.95
    

    const camera = new OrthographicCamera(left,rignt,top,bottom,near,far)
    camera.position.copy(eye)
    camera.lookAt(target)
    console.log(camera);
    const spherical = new Spherical()
    .setFromVector3(
        camera.position.clone().sub(target)
    )
    camera.updateMatrixWorld()
    const pvMatrix = new Matrix4()
    pvMatrix.multiplyMatrices(
        camera.projectionMatrix,
        camera.matrixWorldInverse
    )
    const triangle1 = crtTriangle(
        [ 1 ,0 ,0 ,1 ],
        new Matrix4().setPosition(-0.5, 0, -4).elements
    )
    const triangle2 = crtTriangle(
        [ 1 ,0 ,0 ,1 ],
        new Matrix4().setPosition(0.5, 0, -4).elements
    )
    const triangle3 = crtTriangle(
        [ 1 ,1 ,0 ,1 ],
        new Matrix4().setPosition(-0.5, 0, -2).elements
    )
    const triangle4 = crtTriangle(
        [ 1 ,1 ,0 ,1 ],
        new Matrix4().setPosition(0.5, 0, -2).elements
    )
    
    render()
    function crtTriangle(color,u_ModelMatrix) {
        return new Poly({
            gl,
            source:[
                0, 0.3, 0,
                -0.3, -0.3, 0,
                0.3, -0.3, 0,
            ],
            type: 'TRIANGLES',
            attributes:{
                a_Position:{
                    size: 3,
                    index: 0
                }
            },
            uniforms:{
                u_Color:{
                    type: 'uniform4fv',
                    value: color
                },
                pvMatrix:{
                    type: 'uniformMatrix4fv',
                    value: pvMatrix.elements
                },
                u_ModelMatrix:{
                    type: 'uniformMatrix4fv',
                    value: u_ModelMatrix
                }
            }
        })
    }
    
    function render() {
         // 清空canvas
        gl.clear(gl.COLOR_BUFFER_BIT);
        triangle1.init()
        triangle1.draw()
        triangle2.init()
        triangle2.draw()
        triangle3.init()
        triangle3.draw()
        triangle4.init()
        triangle4.draw()
    }
    
    const mouseButtons = new Map([
        [0, 'rotate'],
        [2, 'pan']
    ])
    const pi2 = Math.PI * 2
    let status = 'none'
    const rotateDir = 'xy'
    const dragStart = new Vector2()
    const dragEnd = new Vector2()
    const panOffset = new Vector3()
    const screenSpacePanning = true
    canvas.addEventListener('contextmenu',e=>e.preventDefault())
    canvas.addEventListener('pointerdown',({clientX,clientY,button})=>{
        status = mouseButtons.get(button)
        dragStart.set(clientX,clientY)
        // state = 
    })
    canvas.addEventListener('wheel',({deltaY})=>{
        camera.zoom *=deltaY<0?1/zoomScale:zoomScale
        camera.updateProjectionMatrix()
        update()
    })
    canvas.addEventListener('pointerup',e=>status = 'none')
    canvas.addEventListener('pointermove',({clientX,clientY})=>{
        dragEnd.set(clientX,clientY)
        switch (status) {
            case 'pan':
                pan(dragEnd.clone().sub(dragStart))
                break;
            case 'rotate':
                rotate(dragEnd.clone().sub(dragStart))
                break;
        }
        dragStart.set(clientX,clientY)

    })
    function rotate({ x, y }) {
        console.log(x,y);
        const { clientHeight } = canvas
        const deltaT = pi2 * x / clientHeight
        const deltaP = pi2 * y / clientHeight
        if (rotateDir.includes('x')) {
            spherical.theta -=deltaT
        }
        if (rotateDir.includes('y')) {
            const phi = spherical.phi -deltaP
            spherical.phi = Math.min(Math.PI* 0.99999999, Math.max(0.00000001,phi))
        }
        update()
    }
    function pan(delta) {
        const cameraW = camera.right -camera.left
        const cameraH = camera.top -camera.bottom

        const ratioX = delta.x / canvas.clientWidth
        const ratioY = delta.y / canvas.clientHeight

        const distanceLeft = ratioX * cameraW
        const distanceUp = ratioY * cameraH

        const mx = new Vector3().setFromMatrixColumn(camera.matrix, 0)
        const vx = mx.clone().multiplyScalar(-distanceLeft)
        const vy = new Vector3()
        if (screenSpacePanning) {
            vy.setFromMatrixColumn(camera.matrix, 1)
        }else{
            vy.crossVectors(camera.up,mx)
        }
        vy.multiplyScalar(distanceUp)
        panOffset.copy(vx.add(vy))
        update()
    }
    function update() {
        target.add(panOffset)
        camera.position.add(panOffset)

        const rotateOffset = new Vector3().setFromSpherical(spherical)
        camera.position.copy(
            target.clone().add(rotateOffset)
        )

        camera.lookAt(target)
        camera.updateWorldMatrix(true)
        pvMatrix.multiplyMatrices(
            camera.projectionMatrix,
            camera.matrixWorldInverse
        )
        console.log(pvMatrix.elements);
        spherical.setFromVector3(
            camera.position.clone().sub(target)
        )
        panOffset.set(0,0,0)
        render()
    }
</script>
</html>