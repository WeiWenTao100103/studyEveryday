<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <canvas id="canvas"></canvas>
</body>
<script type="module">
    import { initShaders } from "./utils/utils.js"
    import Poly from "./utils/Poly.js"
    import { OrthographicCamera ,Matrix4, Vector3, Vector2, Spherical } from "https://unpkg.com/three/build/three.module.js"
    const VSHADER_SOURCE = `
        attribute vec4 a_Position;
        uniform mat4 u_PvMatrix;
        uniform mat4 u_ModelMatrix;
        void main() {
            gl_Position = u_PvMatrix * u_ModelMatrix * a_Position; // 设置坐标位置
        }
    `
    const FSHADER_SOURCE = `
        precision mediump float;
        uniform vec4 u_Color;
        void main(){
            gl_FragColor = u_Color; // 设置颜色
        }
    `
    canvas.width= window.innerWidth;
    canvas.height= window.innerHeight;
    // 获取WebGL绘图上下文
    const gl = canvas.getContext('webgl');
    initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)
    // 指定清空canvas的颜色
    gl.clearColor(0, 0, 0, 1);
    // 清空canvas
    gl.clear(gl.COLOR_BUFFER_BIT);

    const eye = new Vector3(0, 0.5, 2)
    const target = new Vector3(0, 0, -3)
    const up = new Vector3(0, 1, 1)
    const H = 2;
    const ratio = canvas.width/canvas.height
    const W = H * ratio
    const [left,right,top,bottom,near,far] = [ -W, W, H, -H, 1, 8]
    const camera = new OrthographicCamera(left,right,top,bottom,near,far)
    camera.position.copy(eye)
    camera.lookAt(target)
    camera.updateWorldMatrix(true)
    const pvMatrix = new Matrix4()

    pvMatrix.multiplyMatrices(
        camera.projectionMatrix,
        camera.matrixWorldInverse
    )
    const triangle1 = crtTriangle(
        [1, 0, 0, 1],
        new Matrix4().setPosition(-0.5, 0, -4)
    )
    const triangle2 = crtTriangle(
        [1, 0, 0, 1],
        new Matrix4().setPosition(0.5, 0, -4)
    )
    const triangle3 = crtTriangle(
        [1, 1, 0, 1],
        new Matrix4().setPosition(-0.5, 0, -2)
    )
    const triangle4 = crtTriangle(
        [1, 1, 0, 1],
        new Matrix4().setPosition(0.5, 0, -2)
    )
    
    function render() {
        gl.clear(gl.COLOR_BUFFER_BIT);

        triangle1.init()
        triangle1.draw()

        triangle2.init()
        triangle2.draw()

        triangle3.init()
        triangle3.draw()

        triangle4.init()
        triangle4.draw()
    }

    function crtTriangle(color, position) {
        return new Poly({
            gl,
            source: new Float32Array([
                0, 0.3, 0.2,
                -0.3, -0.3, 0.2,
                0.3, -0.3, 0.2,
            ]),
            type: 'TRIANGLES',
            attributes: {
                a_Position: {
                    size: 3,
                    index: 0
                },
            },
            uniforms: {
                u_Color: {
                    type: 'uniform4fv',
                    value: color
                },
                u_ModelMatrix: {
                    type: 'uniformMatrix4fv',
                    value: position.elements
                },
                u_PvMatrix: {
                    type: 'uniformMatrix4fv',
                    value: pvMatrix.elements
                },
            }
        })
    }

    const [dragStart, dragEnd] = [new Vector2, new Vector2]
    let state = 'none'
    const mouseButtons = new Map([
        [2, 'pan'],
        [0, 'rotate']
    ])
    const screenSpacePanning = false
    const offset = new Vector3
    const zoomScale = 0.95
    const spherical = new Spherical()
    spherical.setFromVector3(
        camera.position.clone().sub(target)
    )
    const rotateDir = 'xy'
    const pi2 = Math.PI * 2
    init()

    function init() {
        render()
        bindEvent()
        console.log(spherical);
    }
    function bindEvent() {
        canvas.addEventListener('contextmenu',e=>{
            e.preventDefault()
        })
        canvas.addEventListener('mousedown',({clientX, clientY, button})=>{
            dragStart.set(clientX, clientY)
            state = mouseButtons.get(button)
        })
        canvas.addEventListener('mouseup',e=>{
            state = 'none'
        })
        canvas.addEventListener('mousemove',({clientX, clientY,})=>{
            dragEnd.set(clientX, clientY)
            switch (state) {
                case 'pan':
                    pan(dragEnd.clone().sub(dragStart))
                    break;
                case 'rotate':
                    rotate(dragEnd.clone().sub(dragStart))
                    break;
                default:
                    break;
            }
            dragStart.copy(dragEnd)

        })
        canvas.addEventListener('mousewheel',({deltaY})=>{
            console.log(deltaY);
            if (deltaY>0) {
                // 向下变小0.95
                camera.zoom *= zoomScale
            }else{
                // 向上变大1.05
                camera.zoom *= 1/zoomScale
            }
            camera.updateProjectionMatrix()
            undate()
        })
    }
    function rotate({x,y}) {
        const {clientHeight, clientWidth} = canvas;
        const [deltat, deltap] = [pi2 * x/clientHeight, pi2 * y/clientHeight]
        if (rotateDir.includes('x')) {
            spherical.theta -= deltat
            
        }
        if (rotateDir.includes('y')) {
            const phi = spherical.phi - deltap
            spherical.phi = Math.min(
                Math.max(phi, 0.005),
                Math.PI *0.995
            )
        }


        undate()
        // pi2 * x/clientHeight
    }
    function pan({x,y}) {
      const {left,right,top,bottom,near,far} = camera;
      const {clientHeight, clientWidth} = canvas;
      const ratioH = y/clientHeight
      const ratioW = x/clientWidth
      const distanceLeft = (top-bottom) * ratioH
      const distanceHeight = (right-left) * ratioW

      const mx = new Vector3().setFromMatrixColumn(camera.matrix, 0)
      const vx = mx.clone().multiplyScalar(-distanceHeight)
      const my = new Vector3()
      if (screenSpacePanning) {
        my.setFromMatrixColumn(camera.matrix, 1)
      }else{
        my.crossVectors(camera.up, mx)
      }
      const vy = my.clone().multiplyScalar(distanceLeft)
      offset.copy(vx.add(vy))
      undate()
    }
    function undate() {
        camera.position.add(offset)
        target.add(offset)

        const rotateOffset = new Vector3()
        .setFromSpherical(spherical)

        camera.position.copy(
            target.clone().add(rotateOffset)
        )

        camera.lookAt(target)
        camera.updateWorldMatrix(true)
        pvMatrix.multiplyMatrices(
            camera.projectionMatrix,
            camera.matrixWorldInverse
        )

        spherical.setFromVector3(
            camera.position.clone().sub(target)
        )
        render()
    }
</script>
</html>