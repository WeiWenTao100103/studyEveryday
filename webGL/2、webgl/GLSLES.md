# GLSL ES概述

GLSL ES编程语言是在OpenGL着色器语言（GLSL）的基础上，删除和简化了一部分功能后形成的。 

## 基础

- 程序区分大小写
- 每一个语句都应该以一个英文分号(;)结束

## 执行次序

着色器程序从main()函数开始执行。着色器程序必须有且只有一个main()函数，而且该函数不能接受任何参数。void关键字表示该函数不返回任何值。

在GLSL ES中，如果一个函数有返回值，就必须在定义函数时明确地指定返回值的类型，如果没有返回值，也需要用void来明确表示这个函数没有返回值。

## 注视

GLSL ES的注视和javascript的注视格式是相同的

- 单行注释：//
- 多行注释：/* 中间的所有字符串 */

## 数据值类型

GLSL ES支持两种数据值类型

- 数值类型：GLSL ES支持整形数和浮点数
- 布尔值类型：true和false

## 变量

- 只包括   字母、数字、下划线
- 变量名首字母不能是数字
- 不能是关键字和保留字
- 不能以 gl\_、 webgl\_、 _webgl\_开头

## GLSL ES是强类型语言

在定义函数时，必须指定函数的返回值，同样，在进行赋值操作(=)的时候，等号两边的数据类型也必须一样，否则会报错。

## 基本类型

| 类型  | 描述                                               |
| ----- | -------------------------------------------------- |
| float | 单精度浮点数类型，该类型的变量表示一个单精度浮点数 |
| int   | 整型数，表示整数                                   |
| bool  | 布尔值表示一个布尔值（true或false）                |

## 赋值和类型转换

使用等号(=)进行赋值变量，因为GLSL ES是强类型语言，所以等号左侧变量的类型与等号右侧的值类型必须一致

```c++
int i = 8; //没问题
int i1 = 8.0; //报错
float f1 = 8; //报错
float f2 = 8.0; //没问题
float f3 = 8.0f; //报错
```

语义上8和8.0是一个数值。但是，当你将8赋值给浮点型变量时就会报错。

要将一个整型数值赋值给浮点型变量，需要类型转换

```c++
int i = 8;
float f1 = float(i);
float f2 = float(8);
```

GLSL ES内置的类型转换函数

| 转换               | 函数        | 描述                                     |
| ------------------ | ----------- | ---------------------------------------- |
| 浮点数转换为整型数 | int(float)  | 将浮点数的小数部分删去，转换为整型数     |
| 布尔值转换为整型数 | int(bool)   | true被转换为1，false被转换为0            |
| 整型数转换为浮点数 | float(int)  | 将整型数转换为浮点数(比如，将8转换为8.0) |
| 布尔值转换为浮点数 | float(bool) | true被转换为1.0，false被转换为0.0        |
| 整型数转换为布尔值 | bool(int)   | 0内转换为false，其他非0值被转换为true    |
| 浮点数转换为布尔值 | bool(float) | 0.0被转换为false，其他非0值被转换为true  |

## 矢量与矩阵

GLSL ES支持矢量和矩阵类型，这两种数据类型和适合用来处理计算机图形。矢量和矩阵类型的变量都包含多个元素，每个元素是一个数值（整型数、浮点数、布尔值）。

| 类型 | GLSL ES数据类型     | 描述                            |
| ---- | ------------------- | ------------------------------- |
| 矢量 | vec2、vec3、vec4    | 具有2、3、4个浮点数元素的矢量   |
|      | Ivec2、ivec3、ivec4 | 具有2、3、4个整型数元素的矢量   |
|      | bvec2、bvec3、bvec4 | 具有2、3、4个布尔值元素的矢量   |
| 矩阵 | mat2、mat3、mat4    | 2x2、3x3、4x4的浮点数元素的矩阵 |

## 矢量构造函数

在GLSL ES中，矢量非常重要，所以GLSL ES提供了丰富灵活的方式来创建矢量

```c++
vec3 v3 = vec3(1.0, 0.0, 0.5); //将v3设为(1.0, 0.0, 0.5)
vec2 v2 = vec2(v3);  //将v3设为(1.0, 0.0)
vec2 v4 = vec2(1.0);  //将v3设为(1.0, 1.0, 1.0, 1.0)
```

v2会忽略第三个分量，v4会自动全部赋值给所有的元素，但是如果构造函数接受了不止1个参数，就会报错

## 矩阵构造函数

矩阵构造函数的使用方式和矢量的非常相似。

- 但是，需要保证存储在矩阵的元素时按照列主序排列的（数学中的矩阵时按照行主序排列的）

    ```js
    mat4 m4 = mat4(
        1.0,5.0, 9.0,13.0,
    		2.0,6.0,10.0,14.0,
    		3.0,7.0,11.0,15.0,
    		4.0,8.0,12.0,16.0,
    )
    // 上面矩阵在数学中应该是如下排列
    // 1.0,  2.0,  3.0,  4.0,
    // 5.0,  6.0,  7.0,  8.0,
    // 9.0,  10.0, 11.0, 12.0,
    // 13.0, 14.0, 15.0, 16.0,
    ```
  
- 想矩阵构造函数中传入一个或多个矢量，按照列主序使用矢量里的元素值来构造矩阵

  ```c++
  // 使用两个vec2对象来创建mat2对象
  vec2 v2_1 = vec2(1.0, 3.0);
  vec2 v2_2 = vec2(2.0, 4.0);
  mat2 m2_1 = mat2(v2_1, v2_2);
  // 1.0 2.0
  // 3.0 4.0
  
  // 使用vec4对象来创建mat2对象
  vec4 v4 = vec4(1.0, 3.0, 2.0, 4.0);
  mat2 m2 = mat2(v4)
  // 1.0 2.0
  // 3.0 4.0
  ```

- 如果传入单个数值，回升生成一个对角线元素为该数值，其他元素为0的矩阵

  ~~~c++
  mat4 m4 = mat4(1.0)
  // 1.0 0.0 0.0 0.0
  // 0.0 1.0 0.0 0.0
  // 0.0 0.0 1.0 0.0
  // 0.0 0.0 0.0 1.0
  ~~~

  如果传入的数量大于1，又没有达到矩阵元素的数量会报错

## 访问元素

访问矢量和矩阵中的元素，可以用 . 或 [] 运算法

### .运算符

| 类别    | 描述                 |
| ------- | -------------------- |
| x,y,z,w | 用来获取顶点坐标     |
| r,g,b,a | 用来获取颜色分量     |
| s,t,p,q | 用来获取纹理坐标分量 |

由于矢量可以用来存储顶点的坐标、颜色、纹理坐标，所以GLSL ES支持以上三种分量名称以增强程序的可读性。任何矢量的x,r,s都可以访问第一个分量

```c++
vec3 v3 = vec3(1.0,2.0,3.0);
float f;
f = v3.x; // f=1.0
f = v3.r; // f=1.0
f = v3.s; // f=1.0

f = v3.y; // f=2.0
f = v3.z; // f=3	.0
```

将同一个集合的多个分量名共同置于点运算符后，就可以矢量中同时抽取出多个分量。这个过程称为**混合**

```c++
vec3 v3 = vec3(1.0,2.0,3.0);
vec2 v2;
v2 = v3.xy; //v2为(1.0,2.0)
v2 = v3.zx; //v2为(3.0,1.0)
v2 = v3.xx; //v2为(1.0,1.0)
```

### []运算符

除了 . 运算符和 [] 运算符通过数组下标来访问矢量或矩阵的元素。⚠️矩阵中的元素任然是按照列主序读取的

```c++
mat4 m4 = mat4(
  1.0, 2.0, 3.0, 4.0,
	5.0, 6.0, 7.0, 8.0,
	9.0,10.0,11.0,12.0,
 13.0,14.0,15.0,16.0,
);
vec4 v4 = m4[0]; //1.0,2.0,3.0,4.0
float f1 = m4[1][2];// 第二行第三个元素：7.0
float f2 = m4[2].z;// 第三行z分量元素：11.0
```

## 运算符

当运算赋值操作作用于矢量或矩阵时，实际上是逐分量地对矩阵或分量的每一个元素进行独立地运算赋值。

### 矢量和浮点数的运算

```c++
vec3 v3a =vec3(1.0, 2.0, 3.0);
float f = 1.0;
vec3 v3b = v3a+f; //(2.0,3.0,4.0)
// v3b.x = v3a.x+f
// v3b.y = v3a.y+f
// v3b.z = v3a.z+f
```

### 矢量运算

```c++
vec3 v3a =vec3(1.0, 2.0, 3.0);
vec3 v3b =vec3(4.0, 5.0, 6.0);
vec3 v3c =v3a + v3b;(5.0,7.0,9.0);
// v3c.x = v3a.x+v3b.x
// v3c.y = v3a.y+v3b.y
// v3c.z = v3a.z+v3b.z
```

### 矩阵和浮点数的运算

矩阵与浮点数的运算也同矢量发生在矩阵的每个分量上

### 矩阵右乘矢量

矩阵右乘矢量的结果也是矢量

```c++
v3b = m3a*v3a; 
// v3b.x = m3a[0].x*v3a.x + m3a[1].x*v3a.y + m3a[2].x*v3a.z
// v3b.y = m3a[0].x*v3a.x + m3a[1].x*v3a.y + m3a[2].x*v3a.z
// v3b.z = m3a[0].x*v3a.x + m3a[1].x*v3a.y + m3a[2].x*v3a.z
```

### 矩阵左乘矢量

```c++
v3b = v3a * m3a;
// v3b.x = v3a.x*m3a[0].x + v3a.y*m3a[0].y + v3a.z*m3a[0].x
// v3b.y = v3a.x*m3a[1].x + v3a.y*m3a[1].y + v3a.z*m3a[1].x
// v3b.z = v3a.x*m3a[2].x + v3a.y*m3a[2].y + v3a.z*m3a[2].x
```

## 结构体

GLSL ES支持用户自定义的类型，即结构体。使用关键字struct，将已存在的类型聚合到一起。

```c++
struct light { //定义了结构体类型light
  vec4 color;
  vec3 postion;
}
light l1,l2; //声明了light类型的变量l1和l2
```

### 访问成员

在结构体后跟 . 加上成员名就可以访问变量的成员了

```c++
vec4 color = l1.color;
vec3 postion = l1.postion;
```

### 运算法

结构体的成员可以参与起自身类型支持的任何运算，但是结构体本身只支持两种运算赋值(=)和比较（==、!=）

## 数组

GLSL ES只支持一维数组类型。不支持pop(),push()等操作

```c++
float floatArray[4]; // 声明含有4个浮点数元素的数组
vec4 vec4Array[2]; // 声明含有2个vec4对象的数组
```

## 取样器（纹理）

GLSL ES支持的一种内置类型为取样器(sampler),必须通过该类型变量访问纹理。

两种基本的取样器类型：sampler2D和samplerCube。

取样器变量只能是uniform变量，或者需要访问纹理的函数，如texture2D()函数的参数

```c++
uniform sampler2D u_Sampler;
```

唯一赋值给取样器变量的就是纹理单元编号gl.uniform1i()

```js
gl.uniform1i(u_Sampler, 0)
```

## 程序流程控制：分支和循环

着色器中的分支和循环与JavaScript或c中的几乎无异

### if语句和if-else语句

```c++
if(distance < 0.5){
  gl_FragColor = vec4(1.0,0.0,0.0,1.0);
} else {
  gl_FragColor = vec4(0.0,1.0,0.0,1.0);
}
```

⚠️GLSL ES中没有switch语句

### for语句

```c++
for (int i=0; i<3; i++){
  sum+=i;
}
```

### continue、break、discard语句

continue：中止包含该语句的最内层循环和执行循环表达式，然后执行下一次循环

break：中止包含该语句的最内层循环，并不再继续执行循环

discard：只能在片元着色器中使用，表示放弃当前片元直接处理下一个片元

## 函数

与JavaScript中函数定义的方式不同，GLSL ES定义函数的方式更接近于c语言

```c++
返回类型 函数名(type0 arg0,type1 arg1,type2 arg2,...){
  函数计算;
    return 返回值;
}
```

```c
float luma (vec3 color){
  return 0.2126*color.r + 0.7162*color.g + 0.0722*color.b;
}
attribute vec3 a_Color;
void main(){
  float brightness = luma(a_Color);
}
```

⚠️GLSL ES中不支持在函数内部调用它本身（递归调用是不允许的）

如果函数定义在其调用之后，必须在进行调用之前线声明该函数的规范。该规范会预先告诉系统函数的参数、参数类型、返回值等等

```c
float luma (vec3);// 规范声明
attribute vec3 a_Color;
void main(){
  float brightness = luma(a_Color);// 提前调用
}
float luma (vec3 color){
  return 0.2126*color.r + 0.7162*color.g + 0.0722*color.b;
}
```

### 参数限定词

在GLSL ES中，可以为函数参数指定限定字，用来控制参数的行为。

- 传递给函数的

- 将要在函数中被赋值的

- 既是传递给函数的，也是将要在函数中被赋值的

  | 类别     | 规则                                   | 描述                                                         |
  | -------- | -------------------------------------- | ------------------------------------------------------------ |
  | in       | 向函数中传入值                         | 参数传入函数，函数内可以使用参数的值，也可以修改。但函数内部的修改不会影响传入的变量 |
  | const in | 想函数中传入值                         | 参数传入函数，函数内可以使用参数的值，但不能修改             |
  | out      | 在函数中被赋值，并传出                 | 传入变量的引用，若其在函数内被修改，会影响到函数外部传入的变量 |
  | inout    | 传入函数，同时在函数中被赋值，并被传出 | 传入变量的引用，函数会用到变量的处世之，然后修改变量的值，会影响到函数外部传入的变量 |
  | 无：默认 | 将一个值传给函数                       | 和in一样                                                     |

  例如：给luma函数指定一个out参数，让其接受函数的计算结果,修改如下

  ```c
  void luma (in vec3 color, out float brightness){
    return 0.2126*color.r + 0.7162*color.g + 0.0722*color.b;
  }
  luma(color,brightness)// 函数结果存储在brightness中。和之前的效果一样
  ```

  修改之后，函数本身不返回值，所以返回值为void，第一个参数前面添加限定词in，默认可以省略。结果存储在brightness中

## 全局变量和局部变量

在GLSL ES中和JavaScript一样，如果变量声明在函数的外面，就是全局变量，如果是声明在函数内部，就是局部变量。

### 存储限定字

1. const变量表示不可能改变的变量，改变时会报错。

2. Attribute变量

   attribute变量只能出现在顶点着色器中，只能被声明为全局变量，用来表示逐顶点的信息。

   attribute变量的类型只能是float、vec2、vec3、vec4、mat2、mat3、mat4

3. uniform变量

4. uniform变量可以用在顶点着色器中和片元着色器中，且必须是全局变量。uniform变量是只读的，它可以是除了数组和结构体以外的所有任意类型。如果顶点着色器和片元着色器中声明了同名的uniform变量，那么他就会被两种着色器共享。

   uniform变量包含了“一致”（非逐顶点/逐片元的，各顶点或各片元共用）的数据，JavaScript应该向其传递此类数据

5. varying变量

6. varying变量必须是全局变量，它的任务是从顶点着色器向片元着色器传输数据。必须在顶点着色器和片元着色器声明同名、同类型的varying变量

   varying变量只能是以下类型：float、vec2、vec3、vec4、mat2、mat3、mat4

   顶点着色器中赋值给varying变量的值并不是直接传给了片元着色器的varying变量，这其中发生了光栅化的过程

## 精度限定字

GLSL ES新引入了精读限定字，目的是帮助着色器程序提高运行效率。

高精度的程序需要更大的开销，低精度的程序需要的开销则小的多。使用精度限定字，可以控制程序在效率和性能间的平衡

| 精度限定字 | 描述                         |
| ---------- | ---------------------------- |
| highp      | 高精度，顶点着色器的最低精度 |
| mediump    | 中精度，片元着色器的最低精度 |
| lowp       | 低精度，可以表示所有颜色     |

```c++
mediump float size; //中精度的浮点型变量
highp vec4 postion; //高精度浮点型元素的vec4对象
lowp vec4 color; //低精度浮点型元素的vec4对象
```

以上是为每个变量都声明精度，也可以使用关键字precision来声明着色器的默认精度（必须在着色器的顶部）

⚠️片元着色器中对float类型没有做出了限定

| 着色器类型 | 数据类型    | 默认精度 |
| ---------- | ----------- | -------- |
| 顶点着色器 | int         | highp    |
|            | float       | hight    |
|            | sampler2D   | lowp     |
|            | samplerCube | lowp     |
| 片元着色器 | int         | mediump  |
|            | float       | **无**   |
|            | sampler2D   | lowp     |
|            | samplerCube | lowp     |

在片元着色器中float类型没有默认精度，需要手动指定

```c
precision mediump float;
```

